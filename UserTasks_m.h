// =========== Header ===========// File:				UserTasks_m.h// Project:				ATA Support for Newton OS, Waba// Written by:			Paul Guyot (pguyot@kallisys.net)//// Created on:			06/28/2000// Internal version:	1//// Copyright:			© 2000 by Paul Guyot.// 						All rights reserved worldwide.// ===========// =========== Change History ===========// 06/28/2000	v1	[PG]	Creation of the file// ===========#ifndef __USERTASKS_H#define __USERTASKS_H// From UserTasks.h, just what is required#ifndef __NEWTON_H#include "Newton.h"#endif#ifndef	__SHAREDTYPES_H#include "SharedTypes.h"#endif //__SHAREDTYPES_H#ifndef	__USEROBJECTS_H#include "UserObjects.h"#endif	//__USEROBJECTS_H#ifndef	__LongTime_H#include "LongTime.h"#endif	//__LongTime_H#ifndef __USERGLOBALS_H#include "UserGlobals.h"#endif /*__USERGLOBALS_H*/#include "UserPorts.h"const int kSleepForever = 0xffffffff;		// will cause sleep to never returnextern void Sleep(TTimeout timeout);extern void SleepTill(TTime* futureTime);extern "C" void*	GetGlobals(void);struct SKernelParams{	ULong					fParams[12];			// arguments and return values};struct STaskSwitchedGlobals{	SKernelParams			fKernelParams;			// parameters for kernel calls	int						fErrNo;					// slot for errors from stdio	TObjectId				fDefaultHeapDomainId;	//	void*					fStackTop;				// byte beyond top of stack we are running on	void*					fStackBottom;			// last usable byte in this stack	TObjectId				fTaskId;				// current task id	void *					fCurrentHeap;			// -> current heap	NewtonErr				fMemErr;				// current task's MemError() status	ULong					fTaskName;				// task name, from Init call	/*	**	Exceptions currently assume that fExceptionGlobals appears LAST	**	*/	ExceptionGlobals		fExceptionGlobals;		// globals for try/catch/Throw};enum{	kSpawnedTaskStackSize	= 6000,	kSpawnedTaskAckTimeout	= 15000,	kSpawnedTaskAckMsgType	= 0x00800000};class TUTask : public TUObject{	public:					TUTask(TObjectId id = 0) : TUObject(id) {};		void		operator=(TObjectId id) { CopyObject(id); }		void		operator=(const TUTask& copy) { CopyObject(copy); }		long		Init(TaskProcPtr pc, ULong stackSize, ULong objectSize, void* theObject, ULong priority, ULong taskName, TObjectId environment);		long		Init(TaskProcPtr pc, ULong stackSize, ULong objectSize, void* theObject, ULong priority = kUserTaskPriority, ULong taskName = 'UNAM');		long		Start();		long		Suspend();		long		GetRegister(ULong reg, ULong* value);		long		SetRegister(ULong reg, ULong value);};class TUTaskWorld : public SingleObject{	public:						TUTaskWorld();		virtual			~TUTaskWorld();		long			StartTask(Boolean wantResultFromChild, Boolean wantOwnerShip, TTimeout startTimeout, ULong stackSize, ULong priority, ULong taskName, TObjectId environment);	// make a new task and object		long			StartTask(Boolean wantResultFromChild = true, Boolean wantOwnerShip = false, TTimeout startTimeout = kNoTimeout, ULong stackSize = kSpawnedTaskStackSize, ULong priority = kUserTaskPriority, ULong taskName = 'UNAM');	// make a new task and object		TObjectId		GetChildTaskId() { return fChildTask; }	protected:		virtual	ULong	GetSizeOf() = 0;			// object must return its own size		virtual	long	TaskConstructor();			// spawned task called here to construct itself		virtual	void	TaskDestructor();			// spawned task called here to destroy itself		virtual	void	TaskMain() = 0;				// spawned task called here to begin running		void			TaskEntry(ULong, TObjectId taskId);	// low level entry for spawned task (only in base class)		// these instance vars are used by the task creator (the parent)		Boolean			fIsSpawned;					// this indicates if this object is running a new task		Boolean			fIsOwnedByParent;			// true if parent owns child, false if child independent		Boolean			fWantResult;				// true if result should be passed back from child		TUPort			fMotherPort;				// port used to talk between object in pre and post task state		TUTask			fChildTask;					// created task};struct TULockStack{	VAddr	start;	VAddr	end;};extern long ResetAccountTime();extern long GetNextTaskId(TObjectId lastId, TObjectId* returnId);extern long Yield(TObjectId taskId);long Reboot(NewtonErr error = noErr, ULong rebootType = 0, Boolean safe = false);long SetEnvironment(TObjectId newEnvId, TObjectId* oldEnvId = nil);long GetEnvironment(TObjectId* pEnvID);long EnvironmentHasDomain(TObjectId env_id, TObjectId domain_id, Boolean * pHasDomain, Boolean * pIsManager);long AddDomainToEnvironment(TObjectId env_id, TObjectId dom_id, ULong flags);long RemoveDomainFromEnvironment(TObjectId env_id, TObjectId dom_id);long SetBequeathId(TObjectId to);#endif		// __USERTASKS_M__// ====================================================================== //// Those who do not understand Unix are condemned to reinvent it, poorly. ////                 -- Henry Spencer                                       //// ====================================================================== //